\chapter{Progettazione software}


\section{Classificazione eventi}
Nell'ambito dell'attività di sviluppo del software di videoanalisi del progetto Parksmart sono stati implementati alcuni algoritmi di riconoscimento di particolari eventi, comprendenti lo stato di occupazione di singoli stalli di parcheggio. Il software cosi prodotto viene eseguito su sistemi embedded dedicati al fine di distribuire la computazione dell'attività di riconoscimento per informare l'utente su quale sia lo stallo di parcheggio libero più vicino. Allo stato attuale la classificazione degli eventi comprende esclusivamente la variazione di stato di uno stallo di parcheggio da libero a occupato e viceversa da occupato a libero, ma saranno successivamente introdotti alre categorie di eventi per ampliare il ventaglio di caratteristiche di prodotto sviluppate dal progetto Parksmart.
\vspace{5.7truecm}

\section{Database (DynamoDb AWS)}
Le entità che sono memorizzate nel DBMS in maniera persistente sono telecamere e stalli di parcheggio. Oltre a gli attributi definiti dai requisiti sono stati aggiunti alcuni attributi, membri di indici globali secondari, utili all'amministrazione. Data la tecnologia selezionata (DynamoDb) lo schema progettato ha la seguente struttura:

\vspace{0.5truecm}

\centerline{\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{./img/database_ps.png}}

\vspace{0.5truecm}

\centerline{\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{./img/database_cam.png}}

\vspace{0.5truecm}

Le operazioni che sono state implementate sono le seguenti:


\begin{itemize}
	\item Aggiornamento dello stato (Free/Busy) di uno specifico stallo di parcheggio.
	\item Richiesta di stalli di parcheggio di un geohash: da un geohash in input reperiscono tutti gli stalli di parcheggio che vi appartengono.
	\item Richiesta di stalli di parcheggio a partire da una posizione : data una posizione arbitraria si calcola il geohash e si reperiscono tutti gli stalli che vi appartengono.
	\item Richiesta di stalli di parcheggio a partire da un area geografica delimitata da una coppia di coordinate : date due coppie coordinate si calcolano tutti i geohash all'interno dell'area e si reperiscono tutti gli stalli che vi appartengono.
	\item Richiesta di videocamere a partire da un geohash : da un geohash in input reperiscono tutte le videocamere che vi appartengono.
	\item Richiesta di videocamere a partire da una posizione : data una posizione arbitraria viene calcolato il geohash e si reperiscono tutti le videocamere che vi appartengono.
	\item Richiesta di videocamere a partire da un area geografica delimitata da una coppia di coordinate : date due coppie coordinate si calcolano tutti i geohash all'interno dell'area e si reperiscono tutte le videocamere che vi appartengono.
	\item Richiesta di videocamere per modello : dato uno specifico modello di videocamera vengono reperite tutte le videocamere di quel modello.
	\item Richiesta di viedocamere per produttore : dato un produttore di videocamere si reperiscono tutte le viedeocamere vendute da quel produttore.
\end{itemize}

Date le operazioni appena descritte quelle che saranno utilizzate nell'architettura di interesse sono solo quelle relative a gli stalli di parcheggio.
\vspace{0.5truecm}


\section{NodeJs}
L'applicazione in nodejs è composta da due componenti fondamentali:
\begin{itemize}
	\item Moduli: librerie usate all'interno dell'applicazione.
	\item Routes: identificatori di risorse esposte all'esterno.
\end{itemize}
I moduli di terze parti che sono stai utilizzati comprendono ``Express js" un framework utile per il routing, ``ngeohash" libreria utile per codificare e decodificare dei geohash, ``AWS Sdk" che contiene tutte le librerie necessarie per comunicare con i servizi AWS (Es. DynamoDb), ``node-redis" modulo per eseguire le operazioni in cache e infine ``socket.io"+``socket.io-redis" per notificare gli eventi a gli utenti.
E' stato creato un modulo (``psm") ad-hoc per i nostri scopi che comprende i seguenti file:
\begin{enumerate}
	\item ParkingSpace.js con le seguenti funzioni ``pubbliche":
	\begin{itemize}
			\item updateParkingSpace(idPs) : aggiorna lo stato (Free/Busy) di uno specifico stallo di parcheggio.
			\item getPsByHash(hashSource): da un geohash in input reperiscono tutti gli stalli di parcheggio che vi appartengono.
			\item getPsByPosition(latitude, longitude) : data una posizione arbitraria si calcola il geohash e si reperiscono tutti gli stalli che vi appartengono.
			\item getPsByBounds(latHi, latLo, lngHi, lngLo) : date due coppie coordinate si calcolano tutti i geohash all'interno dell'area e si reperiscono tutti gli stalli che vi appartengono.
		\end{itemize}

	\item Camera.js con le seguenti funzioni ``pubbliche":
	\begin{itemize}
			\item getCamsByHash(hashSource) : da un geohash in input reperiscono tutte le videocamere che vi appartengono.
			\item getCamsByPosition(latitude, longitude) : data una posizione arbitraria viene calcolato il geohash e si reperiscono tutti le videocamere che vi appartengono.
			\item getCamsByBounds(latHi, latLo, lngHi, lngLo) : date due coppie coordinate si calcolano tutti i geohash all'interno dell'area e si reperiscono tutte le videocamere che vi appartengono.
			\item getCamsByModel (model): dato uno specifico modello di videocamera vengono reperite tutte le videocamere di quel modello.
			\item getCamsByVendor (vendor) : dato un venditore di videocamere si reperiscono tutte le viedeocamere vendute da quel produttore.
	\end{itemize}

	\item Websocket.js con le seguenti funzioni ``pubbliche":
	\begin{itemize}
		\item sendMessage(channel, message) : invia un messaggio in uno specifico namespace.
	\end{itemize}
\end{enumerate}

A seguire un frammento di codice dal file PerkingSpace.js

\begin{lstlisting}[caption=Code of getPsByPosition]

var AWS = require('./AWS_config.js').AWS_config();
var dynamo = require('dynamodb-doc');
var geohash = require('ngeohash');
var docClient = new dynamo.DynamoDB();
var async = require('async');



var asyncWorker = function(hash, returnData){

    this.returnData=returnData;
    this.hash=hash;
    this.getHash = function(callback){


        var params = {};
        params.TableName = 'Parking_space';
        params.IndexName = 'GeoHash';
        
        params.KeyConditions = [docClient.Condition('GeoHash', 'EQ', hash)];

        docClient.query(params, function(err, data){

            if(!err && data){
                Array.prototype.push.apply(returnData.Items, data.Items);
                
            }
            callback(err, true);
        });


    }
}


function ParkingSpace(){



	return {
		
		...
		...
		
		getPsByPosition: function(lat, lng, callback) {
		    
		    if(lat && lng && callback && typeof(callback)==='function'){
		        var hash = geohash.encode(lat, lng, 7)
		        
		        var hashArray = geohash.neighbors(hash, 7);
		        hashArray[hashArray.length]=hash;
		        var fnArray = [];
		        var returnData = {};
		        returnData.Items = [];
		        for (var i in hashArray){
		            fnArray[i]= (new asyncWorker(hashArray[i], returnData)).getHash;
		        }
		        async.parallel(fnArray, function(err){

	              	callback(null, returnData);
		           
		        });
		    }
		    else
		        callback('Invalid params', null);
		    
		    
		}, 

		...
	}
}

exports.ParkingSpace= ParkingSpace();


\end{lstlisting}

\vspace{0.5truecm}
Ogni utente, per accedere ad una risorsa esposta all'esterno, deve aggiungere nell'``header" della richiesta il token che gli è stato da cognito dato dopo aver effettuato il login. Quest'ultimo viene verificato con il sistema di autenticazione di AWS e infine salvato in cache. Le risorese esposte all'esterno per gli utenti sono le seguenti:

\lstset{language=HTTP}          

\begin{lstlisting}[frame=single]

HTTP 1.1 
GET /ps/getbyposition

Params:
{
	"lat" : Number,
	"lng" : Number
}

\end{lstlisting}

\vspace{1truecm}
\begin{lstlisting}[frame=single]

HTTP 1.1 
GET /ps/getbyhash

Params:
{
	"hashsource" : String
}

\end{lstlisting}


\begin{lstlisting}[frame=single]

HTTP 1.1 
GET /ps/getbybounds

Params:
{
	"lat_lo" : Number,
	"lng_lo" : Number,
	"lat_hi" : Number,
	"lng_hi" : Number
}

\end{lstlisting}

L'aggiornamento dello stato di occupazione di uno stallo di parcheggio viene effettuato sempre tramite restAPI, in fase di sviluppo le telecamere si stanno autenticando con una ``simple http auth" e di conseguenza ogni telecamera è fornita di username e password. Successivamente verrà usato il meccanismo dei certificati X.509: ogni telecamera sarà fornita di un certificato e sarà presente un database di ceritficati validi.
Per effettuare l'aggiornamento di uno stallo di parcheggio una telecamera deve effettuare una richiesta per la seguente risorsa:


\begin{lstlisting}[frame=single]

HTTPs 1.1 
GET /ps/update

Params:
{
	"IdPs" : String,
	"Free" : Boolean
}

\end{lstlisting}

Oltre all'identità della camera verrà verificata la relazione tra la videocamera e il parcheggio che deve eseere aggiornato di stato.






\section{Redis}
I vantaggi di usare una cache di supporto comune all'intero ``Auto scaling group" rende la condivisione di informazioni molto più semplice riuscendo cosi a salvare informazioni sullo stato dell'utente (es. ultimo token utilizzato) mantenendo comunque un modello stateless per l'applicazione. Per la strutturazione dei dati all'interno di redis viene sfruttata la funzione del ``path matching" cioè la possibilità di effettuare ricerche di chiavi con espressioni regolari. Uno stallo di parcheggio sarà memorizzato nel seguente modo:
\begin{quotation}
\textit{``geohash:idstallo"}
\end{quotation}
 e come valore sarà inserito lo stato dello stallo di parcheggio (0 free, 1 busy)

quindi per reperire tutti gli stalli di un geohash basta richiedere le chiavi 

\begin{quotation}
\textit{``geohash:*"}
\end{quotation}
 oppure  se si vuole ottenere lo stato del singolo stallo di parcheggio basta richiedere 
\begin{quotation}
\textit{``*:idstallo"}
\end{quotation} 
Le informazioni che vengono salvate sono le seguenti:

\begin{table}[htb]
\centering
\caption{Informazioni memorizzate su redis}
\label{my-label}
\begin{tabular}{|l|l|l|l|}
\hline
Chiave               & Struttura chiave & Valore               & Tipo valore \\ \hline
Stallo di parcheggio & geohash:idstallo & Stato di occupazione & Bit         \\ \hline
Token cognito        & idcognito:token  & TTL                  & Number      \\ \hline
\end{tabular}
\end{table}

Ad ogni valore chiave viene assegnato un TTL che viene aggiornato automaticamente ad ogni utilizzo della chiave, meccanismo utile per l'eliminazione dei record che utilizzati meno frequentemente.



\section{Lambda AWS}



